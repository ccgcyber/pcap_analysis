-----------------------------------------------
time:  2013/4/23
problem:
    a_dict = {}
    a_list = []
    for ....
        修改a_dict内容
        a_list.append(a_dict)

    最后发现，a_list里面放的都是同一个dict！！！
solution:
    解决方法很简单，改成如下就行：
    a_list = []
    for ....
        a_dict = {}
        修改a_dict内容
        a_list.append(a_dict)

    浅层的原因：因为append的时候，不会新建一个新的对象插进list，这就导致每次插的都是同一个对象，最后list里面装的全是同一个dict，所以内容就完全一样了（都是最后修改得到的内容）
    深层的原因：一定要深刻认识这个问题，这是跟c很不一样的一个机制
              1：在python内，万物皆对象，连右值都是一个对象（而不是一个简单的常量字符串）
              2：参数传递、赋值过程肯定是用“传对象引用”
              3：当对象引用次数为0的时候，这个对象就会被自动销毁（每被引用一次，引用计数+1；每被del或者变量引用另外一个对象一次，引用计数-1）
              请深刻理解以下这个例子：
              a = 'abcd'
              b = a
              a = 'efg'
              print a
              print b
              输出结果为：efg        abcd
              这是因为1：a引用了‘abcd’这个对象
                     2：b = a，所以b也是引用了‘abcd’这个对象
                     3：a = ‘efg’，导致a作为‘efg’的引用了，而b还是‘abcd’的引用

-----------------------------------------------
time:  2013/4/23
problem:
    文件中的内容是有固定格式的，如将c中的一个struct写入到一个文件中（如顺序为2字节，2字节，4字节），怎么将这个内容读出到python中的变量去
solution：
    烦点的做法：把文件读入到一个string，然后a = string[0:2]，b = string[2:4]这样
    简洁的做法：利用struct的unpack函数

-----------------------------------------------
time:  2013/4/23
tips:
    python中如果要返回多个值，用tuple会很简洁方便～

-----------------------------------------------
time:  2013/4/23
problem:
    解析出来的tcp包头，打印出来的seq_num和ack_num与wireshark的不一致
solution：
    这是因为wireshark在这两个数值上面用的是relative value，而不是absolute value
    relative value的意思是：all SEQ and ACK numbers always start at 0 for the first packet seen in each conversation。

-----------------------------------------------
time:  2013/4/23
tips:
    python中如果打印一个对象中的内容，直接print my_obj.__dict__就行了，很简洁，不用自己写什么print_info函数。。。。
