-----------------------------------------------
time:  2013/4/23
problem:
    a_dict = {}
    a_list = []
    for ....
        修改a_dict内容
        a_list.append(a_dict)

    最后发现，a_list里面放的都是同一个dict！！！
solution:
    解决方法很简单，改成如下就行：
    a_list = []
    for ....
        a_dict = {}
        修改a_dict内容
        a_list.append(a_dict)

    浅层的原因：因为append的时候，不会新建一个新的对象插进list，这就导致每次插的都是同一个对象，最后list里面装的全是同一个dict，所以内容就完全一样了（都是最后修改得到的内容）
    深层的原因：一定要深刻认识这个问题，这是跟c很不一样的一个机制
              1：在python内，万物皆对象，连右值都是一个对象（而不是一个简单的常量字符串）
              2：参数传递、赋值过程肯定是用“传对象引用”
              3：当对象引用次数为0的时候，这个对象就会被自动销毁（每被引用一次，引用计数+1；每被del或者变量引用另外一个对象一次，引用计数-1）
              请深刻理解以下这个例子：
              a = 'abcd'
              b = a
              a = 'efg'
              print a
              print b
              输出结果为：efg        abcd
              这是因为1：a引用了‘abcd’这个对象
                     2：b = a，所以b也是引用了‘abcd’这个对象
                     3：a = ‘efg’，导致a作为‘efg’的引用了，而b还是‘abcd’的引用

-----------------------------------------------
time:  2013/4/23
problem:
    文件中的内容是有固定格式的，如将c中的一个struct写入到一个文件中（如顺序为2字节，2字节，4字节），怎么将这个内容读出到python中的变量去
solution：
    烦点的做法：把文件读入到一个string，然后a = string[0:2]，b = string[2:4]这样
    简洁的做法：利用struct的unpack函数

-----------------------------------------------
time:  2013/4/23
tips:
    python中如果要返回多个值，用tuple会很简洁方便～

-----------------------------------------------
time:  2013/4/23
problem:
    解析出来的tcp包头，打印出来的seq_num和ack_num与wireshark的不一致
solution：
    这是因为wireshark在这两个数值上面用的是relative value，而不是absolute value
    relative value的意思是：all SEQ and ACK numbers always start at 0 for the first packet seen in each conversation。

-----------------------------------------------
time:  2013/4/23
tips:
    python中如果打印一个对象中的内容，直接print my_obj.__dict__就行了，很简洁，不用自己写什么print_info函数。。。。

-----------------------------------------------
time:  2013/4/26
problem:
    if (a < b || b < c):
    有语法错误。。。
solution：
    python里面不让这样的，要用“or”还有“and”。。。。

-----------------------------------------------
time:  2013/5/2
problem:
    很多浏览器对页面都会有缓存，若在请求中加入“If Modified Since”，这样，服务器返回一个http 304（服务器就不用返回这个页面内容了）
    浏览器就能用cache的内容了，这对这个项目是一个很大的问题（因为我是依据第一个请求作为分隔session的依据的）
solution：
    这个不是solution！浏览器ctr+f5可以不用cache
    这个只是能用于我测试这个工程能不能正常用于没cache的状况，有cache真的是无能为力

-----------------------------------------------
time:  2013/5/2
tips:
    对网页进行抓包的时候，如果服务器返回的结果是gzip-encode那么content里面的是通过压缩的内容，而wireshark会自动对其解压缩，
    得出解压缩后的内容（需要验证一下这个内容在不在pcap文件内，还是说这个功能是wireshark客户端读pcap文件后做的一个处理）
    另外wireshark还提供一个reassemble segment的功能，需要验证一下这个重组后的内容是否存在pcap文件中，如果不在，需要自己做很麻烦
    上述这些功能都是wireshark对pcap包解析后显示的额外信息，pcap文件里面是没有这些东西的（本来pcap文件就是抓取到的很底层的数据
    怎么可能会出现这种很上层功能才能实现的内容呢？）

-----------------------------------------------
time:  2013/5/8
tips:
    a[::-1]将a中内容倒序
